.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FFMPEG-FORMATS 1"
.TH FFMPEG-FORMATS 1 "2013-05-03" " " " "
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ffmpeg\-formats \- FFmpeg formats
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes the supported formats (muxers and demuxers)
provided by the libavformat library.
.SH "FORMAT OPTIONS"
.IX Header "FORMAT OPTIONS"
The libavformat library provides some generic global options, which
can be set on all the muxers and demuxers. In addition each muxer or
demuxer may support so-called private options, which are specific for
that component.
.PP
Options may be set by specifying \-\fIoption\fR \fIvalue\fR in the
FFmpeg tools, or by setting the value explicitly in the
\&\f(CW\*(C`AVFormatContext\*(C'\fR options or using the \fIlibavutil/opt.h\fR \s-1API\s0
for programmatic use.
.PP
The list of supported options follows:
.IP "\fBavioflags\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "avioflags flags (input/output)"
Possible values:
.RS 4
.IP "\fBdirect\fR" 4
.IX Item "direct"
Reduce buffering.
.RE
.RS 4
.RE
.IP "\fBprobesize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "probesize integer (input)"
Set probing size in bytes, i.e. the size of the data to analyze to get
stream information. A higher value will allow to detect more
information in case it is dispersed into the stream, but will increase
latency. Must be an integer not lesser than 32. It is 5000000 by default.
.IP "\fBpacketsize\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "packetsize integer (output)"
Set packet size.
.IP "\fBfflags\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "fflags flags (input/output)"
Set format flags.
.Sp
Possible values:
.RS 4
.IP "\fBignidx\fR" 4
.IX Item "ignidx"
Ignore index.
.IP "\fBgenpts\fR" 4
.IX Item "genpts"
Generate \s-1PTS\s0.
.IP "\fBnofillin\fR" 4
.IX Item "nofillin"
Do not fill in missing values that can be exactly calculated.
.IP "\fBnoparse\fR" 4
.IX Item "noparse"
Disable AVParsers, this needs \f(CW\*(C`+nofillin\*(C'\fR too.
.IP "\fBigndts\fR" 4
.IX Item "igndts"
Ignore \s-1DTS\s0.
.IP "\fBdiscardcorrupt\fR" 4
.IX Item "discardcorrupt"
Discard corrupted frames.
.IP "\fBsortdts\fR" 4
.IX Item "sortdts"
Try to interleave output packets by \s-1DTS\s0.
.IP "\fBkeepside\fR" 4
.IX Item "keepside"
Do not merge side data.
.IP "\fBlatm\fR" 4
.IX Item "latm"
Enable \s-1RTP\s0 \s-1MP4A\-LATM\s0 payload.
.IP "\fBnobuffer\fR" 4
.IX Item "nobuffer"
Reduce the latency introduced by optional buffering
.RE
.RS 4
.RE
.IP "\fBanalyzeduration\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "analyzeduration integer (input)"
Specify how many microseconds are analyzed to probe the input. A
higher value will allow to detect more accurate information, but will
increase latency. It defaults to 5,000,000 microseconds = 5 seconds.
.IP "\fBcryptokey\fR \fIhexadecimal string\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "cryptokey hexadecimal string (input)"
Set decryption key.
.IP "\fBindexmem\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "indexmem integer (input)"
Set max memory used for timestamp index (per stream).
.IP "\fBrtbufsize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "rtbufsize integer (input)"
Set max memory used for buffering real-time frames.
.IP "\fBfdebug\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "fdebug flags (input/output)"
Print specific debug info.
.Sp
Possible values:
.RS 4
.IP "\fBts\fR" 4
.IX Item "ts"
.RE
.RS 4
.RE
.PD 0
.IP "\fBmax_delay\fR \fIinteger\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "max_delay integer (input/output)"
.PD
Set maximum muxing or demuxing delay in microseconds.
.IP "\fBfpsprobesize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "fpsprobesize integer (input)"
Set number of frames used to probe fps.
.IP "\fBaudio_preload\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "audio_preload integer (output)"
Set microseconds by which audio packets should be interleaved earlier.
.IP "\fBchunk_duration\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "chunk_duration integer (output)"
Set microseconds for each chunk.
.IP "\fBchunk_size\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "chunk_size integer (output)"
Set size in bytes for each chunk.
.IP "\fBerr_detect, f_err_detect\fR \fIflags\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "err_detect, f_err_detect flags (input)"
Set error detection flags. \f(CW\*(C`f_err_detect\*(C'\fR is deprecated and
should be used only via the \fBffmpeg\fR tool.
.Sp
Possible values:
.RS 4
.IP "\fBcrccheck\fR" 4
.IX Item "crccheck"
Verify embedded CRCs.
.IP "\fBbitstream\fR" 4
.IX Item "bitstream"
Detect bitstream specification deviations.
.IP "\fBbuffer\fR" 4
.IX Item "buffer"
Detect improper bitstream length.
.IP "\fBexplode\fR" 4
.IX Item "explode"
Abort decoding on minor error detection.
.IP "\fBcareful\fR" 4
.IX Item "careful"
Consider things that violate the spec and have not been seen in the
wild as errors.
.IP "\fBcompliant\fR" 4
.IX Item "compliant"
Consider all spec non compliancies as errors.
.IP "\fBaggressive\fR" 4
.IX Item "aggressive"
Consider things that a sane encoder should not do as an error.
.RE
.RS 4
.RE
.IP "\fBuse_wallclock_as_timestamps\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "use_wallclock_as_timestamps integer (input)"
Use wallclock as timestamps.
.IP "\fBavoid_negative_ts\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "avoid_negative_ts integer (output)"
Shift timestamps to make them positive. 1 enables, 0 disables, default
of \-1 enables when required by target format.
.SH "DEMUXERS"
.IX Header "DEMUXERS"
Demuxers are configured elements in FFmpeg which allow to read the
multimedia streams from a particular type of file.
.PP
When you configure your FFmpeg build, all the supported demuxers
are enabled by default. You can list all available ones using the
configure option \f(CW\*(C`\-\-list\-demuxers\*(C'\fR.
.PP
You can disable all the demuxers using the configure option
\&\f(CW\*(C`\-\-disable\-demuxers\*(C'\fR, and selectively enable a single demuxer with
the option \f(CW\*(C`\-\-enable\-demuxer=\f(CIDEMUXER\f(CW\*(C'\fR, or disable it
with the option \f(CW\*(C`\-\-disable\-demuxer=\f(CIDEMUXER\f(CW\*(C'\fR.
.PP
The option \f(CW\*(C`\-formats\*(C'\fR of the ff* tools will display the list of
enabled demuxers.
.PP
The description of some of the currently available demuxers follows.
.SS "applehttp"
.IX Subsection "applehttp"
Apple \s-1HTTP\s0 Live Streaming demuxer.
.PP
This demuxer presents all AVStreams from all variant streams.
The id field is set to the bitrate variant index number. By setting
the discard flags on AVStreams (by pressing 'a' or 'v' in ffplay),
the caller can decide which variant streams to actually receive.
The total bitrate of the variant that the stream belongs to is
available in a metadata key named \*(L"variant_bitrate\*(R".
.SS "concat"
.IX Subsection "concat"
Virtual concatenation script demuxer.
.PP
This demuxer reads a list of files and other directives from a text file and
demuxes them one after the other, as if all their packet had been muxed
together.
.PP
The timestamps in the files are adjusted so that the first file starts at 0
and each next file starts where the previous one finishes. Note that it is
done globally and may cause gaps if all streams do not have exactly the same
length.
.PP
All files must have the same streams (same codecs, same time base, etc.).
.PP
The duration of each file is used to adjust the timestamps of the next file:
if the duration is incorrect (because it was computed using the bit-rate or
because the file is truncated, for example), it can cause artifacts. The
\&\f(CW\*(C`duration\*(C'\fR directive can be used to override the duration stored in
each file.
.PP
\fISyntax\fR
.IX Subsection "Syntax"
.PP
The script is a text file in extended-ASCII, with one directive per line.
Empty lines, leading spaces and lines starting with '#' are ignored. The
following directive is recognized:
.ie n .IP "\fB\fB""file \f(BIpath\f(CB""\fB\fR" 4
.el .IP "\fB\f(CBfile \f(CBpath\f(CB\fB\fR" 4
.IX Item "file path"
Path to a file to read; special characters and spaces must be escaped with
backslash or single quotes.
.Sp
All subsequent directives apply to that file.
.ie n .IP "\fB\fB""ffconcat version 1.0""\fB\fR" 4
.el .IP "\fB\f(CBffconcat version 1.0\fB\fR" 4
.IX Item "ffconcat version 1.0"
Identify the script type and version. It also sets the \fBsafe\fR option
to 1 if it was to its default \-1.
.Sp
To make FFmpeg recognize the format automatically, this directive must
appears exactly as is (no extra space or byte-order-mark) on the very first
line of the script.
.ie n .IP "\fB\fB""duration \f(BIdur\f(CB""\fB\fR" 4
.el .IP "\fB\f(CBduration \f(CBdur\f(CB\fB\fR" 4
.IX Item "duration dur"
Duration of the file. This information can be specified from the file;
specifying it here may be more efficient or help if the information from the
file is not available or accurate.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
This demuxer accepts the following option:
.IP "\fBsafe\fR" 4
.IX Item "safe"
If set to 1, reject unsafe file paths. A file path is considered safe if it
does not contain a protocol specification and is relative and all components
only contain characters from the portable character set (letters, digits,
period, underscore and hyphen) and have no period at the beginning of a
component.
.Sp
If set to 0, any file name is accepted.
.Sp
The default is \-1, it is equivalent to 1 if the format was automatically
probed and 0 otherwise.
.SS "image2"
.IX Subsection "image2"
Image file demuxer.
.PP
This demuxer reads from a list of image files specified by a pattern.
The syntax and meaning of the pattern is specified by the
option \fIpattern_type\fR.
.PP
The pattern may contain a suffix which is used to automatically
determine the format of the images contained in the files.
.PP
The size, the pixel format, and the format of each image must be the
same for all the files in the sequence.
.PP
This demuxer accepts the following options:
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set the framerate for the video stream. It defaults to 25.
.IP "\fBloop\fR" 4
.IX Item "loop"
If set to 1, loop over the input. Default value is 0.
.IP "\fBpattern_type\fR" 4
.IX Item "pattern_type"
Select the pattern type used to interpret the provided filename.
.Sp
\&\fIpattern_type\fR accepts one of the following values.
.RS 4
.IP "\fBsequence\fR" 4
.IX Item "sequence"
Select a sequence pattern type, used to specify a sequence of files
indexed by sequential numbers.
.Sp
A sequence pattern may contain the string \*(L"%d\*(R" or "%0\fIN\fRd\*(L", which
specifies the position of the characters representing a sequential
number in each filename matched by the pattern. If the form
\&\*(R"%d0\fIN\fRd" is used, the string representing the number in each
filename is 0\-padded and \fIN\fR is the total number of 0\-padded
digits representing the number. The literal character '%' can be
specified in the pattern with the string \*(L"%%\*(R".
.Sp
If the sequence pattern contains \*(L"%d\*(R" or "%0\fIN\fRd", the first filename of
the file list specified by the pattern must contain a number
inclusively contained between \fIstart_number\fR and
\&\fIstart_number\fR+\fIstart_number_range\fR\-1, and all the following
numbers must be sequential.
.Sp
For example the pattern \*(L"img\-%03d.bmp\*(R" will match a sequence of
filenames of the form \fIimg\-001.bmp\fR, \fIimg\-002.bmp\fR, ...,
\&\fIimg\-010.bmp\fR, etc.; the pattern \*(L"i%%m%%g\-%d.jpg\*(R" will match a
sequence of filenames of the form \fIi%m%g\-1.jpg\fR,
\&\fIi%m%g\-2.jpg\fR, ..., \fIi%m%g\-10.jpg\fR, etc.
.Sp
Note that the pattern must not necessarily contain \*(L"%d\*(R" or
"%0\fIN\fRd", for example to convert a single image file
\&\fIimg.jpeg\fR you can employ the command:
.Sp
.Vb 1
\&        ffmpeg \-i img.jpeg img.png
.Ve
.IP "\fBglob\fR" 4
.IX Item "glob"
Select a glob wildcard pattern type.
.Sp
The pattern is interpreted like a \f(CW\*(C`glob()\*(C'\fR pattern. This is only
selectable if libavformat was compiled with globbing support.
.IP "\fBglob_sequence\fR \fI(deprecated, will be removed)\fR" 4
.IX Item "glob_sequence (deprecated, will be removed)"
Select a mixed glob wildcard/sequence pattern.
.Sp
If your version of libavformat was compiled with globbing support, and
the provided pattern contains at least one glob meta character among
\&\f(CW\*(C`%*?[]{}\*(C'\fR that is preceded by an unescaped \*(L"%\*(R", the pattern is
interpreted like a \f(CW\*(C`glob()\*(C'\fR pattern, otherwise it is interpreted
like a sequence pattern.
.Sp
All glob special characters \f(CW\*(C`%*?[]{}\*(C'\fR must be prefixed
with \*(L"%\*(R". To escape a literal \*(L"%\*(R" you shall use \*(L"%%\*(R".
.Sp
For example the pattern \f(CW\*(C`foo\-%*.jpeg\*(C'\fR will match all the
filenames prefixed by \*(L"foo\-\*(R" and terminating with \*(L".jpeg\*(R", and
\&\f(CW\*(C`foo\-%?%?%?.jpeg\*(C'\fR will match all the filenames prefixed with
\&\*(L"foo\-\*(R", followed by a sequence of three characters, and terminating
with \*(L".jpeg\*(R".
.Sp
This pattern type is deprecated in favor of \fIglob\fR and
\&\fIsequence\fR.
.RE
.RS 4
.Sp
Default value is \fIglob_sequence\fR.
.RE
.IP "\fBpixel_format\fR" 4
.IX Item "pixel_format"
Set the pixel format of the images to read. If not specified the pixel
format is guessed from the first image file in the sequence.
.IP "\fBstart_number\fR" 4
.IX Item "start_number"
Set the index of the file matched by the image file pattern to start
to read from. Default value is 0.
.IP "\fBstart_number_range\fR" 4
.IX Item "start_number_range"
Set the index interval range to check when looking for the first image
file in the sequence, starting from \fIstart_number\fR. Default value
is 5.
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set the video size of the images to read. If not specified the video
size is guessed from the first image file in the sequence.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Use \fBffmpeg\fR for creating a video from the images in the file
sequence \fIimg\-001.jpeg\fR, \fIimg\-002.jpeg\fR, ..., assuming an
input frame rate of 10 frames per second:
.Sp
.Vb 1
\&        ffmpeg \-i \*(Aqimg\-%03d.jpeg\*(Aq \-r 10 out.mkv
.Ve
.IP "\(bu" 4
As above, but start by reading from a file with index 100 in the sequence:
.Sp
.Vb 1
\&        ffmpeg \-start_number 100 \-i \*(Aqimg\-%03d.jpeg\*(Aq \-r 10 out.mkv
.Ve
.IP "\(bu" 4
Read images matching the \*(L"*.png\*(R" glob pattern , that is all the files
terminating with the \*(L".png\*(R" suffix:
.Sp
.Vb 1
\&        ffmpeg \-pattern_type glob \-i "*.png" \-r 10 out.mkv
.Ve
.SS "rawvideo"
.IX Subsection "rawvideo"
Raw video demuxer.
.PP
This demuxer allows to read raw video data. Since there is no header
specifying the assumed video parameters, the user must specify them
in order to be able to decode the data correctly.
.PP
This demuxer accepts the following options:
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set input video frame rate. Default value is 25.
.IP "\fBpixel_format\fR" 4
.IX Item "pixel_format"
Set the input video pixel format. Default value is \f(CW\*(C`yuv420p\*(C'\fR.
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set the input video size. This value must be specified explicitly.
.PP
For example to read a rawvideo file \fIinput.raw\fR with
\&\fBffplay\fR, assuming a pixel format of \f(CW\*(C`rgb24\*(C'\fR, a video
size of \f(CW\*(C`320x240\*(C'\fR, and a frame rate of 10 images per second, use
the command:
.PP
.Vb 1
\&        ffplay \-f rawvideo \-pixel_format rgb24 \-video_size 320x240 \-framerate 10 input.raw
.Ve
.SS "sbg"
.IX Subsection "sbg"
SBaGen script demuxer.
.PP
This demuxer reads the script language used by SBaGen
<\fBhttp://uazu.net/sbagen/\fR> to generate binaural beats sessions. A \s-1SBG\s0
script looks like that:
.PP
.Vb 9
\&        \-SE
\&        a: 300\-2.5/3 440+4.5/0
\&        b: 300\-2.5/0 440+4.5/3
\&        off: \-
\&        NOW      == a
\&        +0:07:00 == b
\&        +0:14:00 == a
\&        +0:21:00 == b
\&        +0:30:00    off
.Ve
.PP
A \s-1SBG\s0 script can mix absolute and relative timestamps. If the script uses
either only absolute timestamps (including the script start time) or only
relative ones, then its layout is fixed, and the conversion is
straightforward. On the other hand, if the script mixes both kind of
timestamps, then the \fI\s-1NOW\s0\fR reference for relative timestamps will be
taken from the current time of day at the time the script is read, and the
script layout will be frozen according to that reference. That means that if
the script is directly played, the actual times will match the absolute
timestamps up to the sound controller's clock accuracy, but if the user
somehow pauses the playback or seeks, all times will be shifted accordingly.
.SS "tedcaptions"
.IX Subsection "tedcaptions"
\&\s-1JSON\s0 captions used for <\fBhttp://www.ted.com/\fR>.
.PP
\&\s-1TED\s0 does not provide links to the captions, but they can be guessed from the
page. The file \fItools/bookmarklets.html\fR from the FFmpeg source tree
contains a bookmarklet to expose them.
.PP
This demuxer accepts the following option:
.IP "\fBstart_time\fR" 4
.IX Item "start_time"
Set the start time of the \s-1TED\s0 talk, in milliseconds. The default is 15000
(15s). It is used to sync the captions with the downloadable videos, because
they include a 15s intro.
.PP
Example: convert the captions to a format most players understand:
.PP
.Vb 1
\&        ffmpeg \-i http://www.ted.com/talks/subtitles/id/1/lang/en talk1\-en.srt
.Ve
.SH "MUXERS"
.IX Header "MUXERS"
Muxers are configured elements in FFmpeg which allow writing
multimedia streams to a particular type of file.
.PP
When you configure your FFmpeg build, all the supported muxers
are enabled by default. You can list all available muxers using the
configure option \f(CW\*(C`\-\-list\-muxers\*(C'\fR.
.PP
You can disable all the muxers with the configure option
\&\f(CW\*(C`\-\-disable\-muxers\*(C'\fR and selectively enable / disable single muxers
with the options \f(CW\*(C`\-\-enable\-muxer=\f(CIMUXER\f(CW\*(C'\fR /
\&\f(CW\*(C`\-\-disable\-muxer=\f(CIMUXER\f(CW\*(C'\fR.
.PP
The option \f(CW\*(C`\-formats\*(C'\fR of the ff* tools will display the list of
enabled muxers.
.PP
A description of some of the currently available muxers follows.
.SS "crc"
.IX Subsection "crc"
\&\s-1CRC\s0 (Cyclic Redundancy Check) testing format.
.PP
This muxer computes and prints the Adler\-32 \s-1CRC\s0 of all the input audio
and video frames. By default audio frames are converted to signed
16\-bit raw audio and video frames to raw video before computing the
\&\s-1CRC\s0.
.PP
The output of the muxer consists of a single line of the form:
CRC=0x\fI\s-1CRC\s0\fR, where \fI\s-1CRC\s0\fR is a hexadecimal number 0\-padded to
8 digits containing the \s-1CRC\s0 for all the decoded input frames.
.PP
For example to compute the \s-1CRC\s0 of the input, and store it in the file
\&\fIout.crc\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f crc out.crc
.Ve
.PP
You can print the \s-1CRC\s0 to stdout with the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f crc \-
.Ve
.PP
You can select the output format of each frame with \fBffmpeg\fR by
specifying the audio and video codec and format. For example to
compute the \s-1CRC\s0 of the input audio converted to \s-1PCM\s0 unsigned 8\-bit
and the input video converted to \s-1MPEG\-2\s0 video, use the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-c:a pcm_u8 \-c:v mpeg2video \-f crc \-
.Ve
.PP
See also the framecrc muxer.
.SS "framecrc"
.IX Subsection "framecrc"
Per-packet \s-1CRC\s0 (Cyclic Redundancy Check) testing format.
.PP
This muxer computes and prints the Adler\-32 \s-1CRC\s0 for each audio
and video packet. By default audio frames are converted to signed
16\-bit raw audio and video frames to raw video before computing the
\&\s-1CRC\s0.
.PP
The output of the muxer consists of a line for each audio and video
packet of the form:
.PP
.Vb 1
\&        <stream_index>, <packet_dts>, <packet_pts>, <packet_duration>, <packet_size>, 0x<CRC>
.Ve
.PP
\&\fI\s-1CRC\s0\fR is a hexadecimal number 0\-padded to 8 digits containing the
\&\s-1CRC\s0 of the packet.
.PP
For example to compute the \s-1CRC\s0 of the audio and video frames in
\&\fI\s-1INPUT\s0\fR, converted to raw audio and video packets, and store it
in the file \fIout.crc\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framecrc out.crc
.Ve
.PP
To print the information to stdout, use the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framecrc \-
.Ve
.PP
With \fBffmpeg\fR, you can select the output format to which the
audio and video frames are encoded before computing the \s-1CRC\s0 for each
packet by specifying the audio and video codec. For example, to
compute the \s-1CRC\s0 of each decoded input audio frame converted to \s-1PCM\s0
unsigned 8\-bit and of each decoded input video frame converted to
\&\s-1MPEG\-2\s0 video, use the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-c:a pcm_u8 \-c:v mpeg2video \-f framecrc \-
.Ve
.PP
See also the crc muxer.
.SS "framemd5"
.IX Subsection "framemd5"
Per-packet \s-1MD5\s0 testing format.
.PP
This muxer computes and prints the \s-1MD5\s0 hash for each audio
and video packet. By default audio frames are converted to signed
16\-bit raw audio and video frames to raw video before computing the
hash.
.PP
The output of the muxer consists of a line for each audio and video
packet of the form:
.PP
.Vb 1
\&        <stream_index>, <packet_dts>, <packet_pts>, <packet_duration>, <packet_size>, <MD5>
.Ve
.PP
\&\fI\s-1MD5\s0\fR is a hexadecimal number representing the computed \s-1MD5\s0 hash
for the packet.
.PP
For example to compute the \s-1MD5\s0 of the audio and video frames in
\&\fI\s-1INPUT\s0\fR, converted to raw audio and video packets, and store it
in the file \fIout.md5\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framemd5 out.md5
.Ve
.PP
To print the information to stdout, use the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framemd5 \-
.Ve
.PP
See also the md5 muxer.
.SS "hls"
.IX Subsection "hls"
Apple \s-1HTTP\s0 Live Streaming muxer that segments MPEG-TS according to
the \s-1HTTP\s0 Live Streaming specification.
.PP
It creates a playlist file and numbered segment files. The output
filename specifies the playlist filename; the segment filenames
receive the same basename as the playlist, a sequential number and
a .ts extension.
.PP
.Vb 1
\&        ffmpeg \-i in.nut out.m3u8
.Ve
.IP "\fB\-hls_time\fR \fIseconds\fR" 4
.IX Item "-hls_time seconds"
Set the segment length in seconds.
.IP "\fB\-hls_list_size\fR \fIsize\fR" 4
.IX Item "-hls_list_size size"
Set the maximum number of playlist entries.
.IP "\fB\-hls_wrap\fR \fIwrap\fR" 4
.IX Item "-hls_wrap wrap"
Set the number after which index wraps.
.IP "\fB\-start_number\fR \fInumber\fR" 4
.IX Item "-start_number number"
Start the sequence from \fInumber\fR.
.SS "ico"
.IX Subsection "ico"
\&\s-1ICO\s0 file muxer.
.PP
Microsoft's icon file format (\s-1ICO\s0) has some strict limitations that should be noted:
.IP "\(bu" 4
Size cannot exceed 256 pixels in any dimension
.IP "\(bu" 4
Only \s-1BMP\s0 and \s-1PNG\s0 images can be stored
.IP "\(bu" 4
If a \s-1BMP\s0 image is used, it must be one of the following pixel formats:
.Sp
.Vb 7
\&        BMP Bit Depth      FFmpeg Pixel Format
\&        1bit               pal8
\&        4bit               pal8
\&        8bit               pal8
\&        16bit              rgb555le
\&        24bit              bgr24
\&        32bit              bgra
.Ve
.IP "\(bu" 4
If a \s-1BMP\s0 image is used, it must use the \s-1BITMAPINFOHEADER\s0 \s-1DIB\s0 header
.IP "\(bu" 4
If a \s-1PNG\s0 image is used, it must use the rgba pixel format
.SS "image2"
.IX Subsection "image2"
Image file muxer.
.PP
The image file muxer writes video frames to image files.
.PP
The output filenames are specified by a pattern, which can be used to
produce sequentially numbered series of files.
The pattern may contain the string \*(L"%d\*(R" or "%0\fIN\fRd\*(L", this string
specifies the position of the characters representing a numbering in
the filenames. If the form \*(R"%0\fIN\fRd" is used, the string
representing the number in each filename is 0\-padded to \fIN\fR
digits. The literal character '%' can be specified in the pattern with
the string \*(L"%%\*(R".
.PP
If the pattern contains \*(L"%d\*(R" or "%0\fIN\fRd", the first filename of
the file list specified will contain the number 1, all the following
numbers will be sequential.
.PP
The pattern may contain a suffix which is used to automatically
determine the format of the image files to write.
.PP
For example the pattern \*(L"img\-%03d.bmp\*(R" will specify a sequence of
filenames of the form \fIimg\-001.bmp\fR, \fIimg\-002.bmp\fR, ...,
\&\fIimg\-010.bmp\fR, etc.
The pattern \*(L"img%%\-%d.jpg\*(R" will specify a sequence of filenames of the
form \fIimg%\-1.jpg\fR, \fIimg%\-2.jpg\fR, ..., \fIimg%\-10.jpg\fR,
etc.
.PP
The following example shows how to use \fBffmpeg\fR for creating a
sequence of files \fIimg\-001.jpeg\fR, \fIimg\-002.jpeg\fR, ...,
taking one image every second from the input video:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-vsync 1 \-r 1 \-f image2 \*(Aqimg\-%03d.jpeg\*(Aq
.Ve
.PP
Note that with \fBffmpeg\fR, if the format is not specified with the
\&\f(CW\*(C`\-f\*(C'\fR option and the output filename specifies an image file
format, the image2 muxer is automatically selected, so the previous
command can be written as:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-vsync 1 \-r 1 \*(Aqimg\-%03d.jpeg\*(Aq
.Ve
.PP
Note also that the pattern must not necessarily contain \*(L"%d\*(R" or
"%0\fIN\fRd", for example to create a single image file
\&\fIimg.jpeg\fR from the input video you can employ the command:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-f image2 \-frames:v 1 img.jpeg
.Ve
.IP "\fBstart_number\fR \fInumber\fR" 4
.IX Item "start_number number"
Start the sequence from \fInumber\fR. Default value is 1. Must be a
positive number.
.IP "\fBupdatefirst 1|0\fR" 4
.IX Item "updatefirst 1|0"
If set to 1, update the first written image file again and
again. Default value is 0.
.PP
The image muxer supports the .Y.U.V image file format. This format is
special in that that each image frame consists of three files, for
each of the \s-1YUV420P\s0 components. To read or write this image file format,
specify the name of the '.Y' file. The muxer will automatically open the
\&'.U' and '.V' files as required.
.SS "md5"
.IX Subsection "md5"
\&\s-1MD5\s0 testing format.
.PP
This muxer computes and prints the \s-1MD5\s0 hash of all the input audio
and video frames. By default audio frames are converted to signed
16\-bit raw audio and video frames to raw video before computing the
hash.
.PP
The output of the muxer consists of a single line of the form:
MD5=\fI\s-1MD5\s0\fR, where \fI\s-1MD5\s0\fR is a hexadecimal number representing
the computed \s-1MD5\s0 hash.
.PP
For example to compute the \s-1MD5\s0 hash of the input converted to raw
audio and video, and store it in the file \fIout.md5\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f md5 out.md5
.Ve
.PP
You can print the \s-1MD5\s0 to stdout with the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f md5 \-
.Ve
.PP
See also the framemd5 muxer.
.SS "\s-1MOV/MP4/ISMV\s0"
.IX Subsection "MOV/MP4/ISMV"
The mov/mp4/ismv muxer supports fragmentation. Normally, a \s-1MOV/MP4\s0
file has all the metadata about all packets stored in one location
(written at the end of the file, it can be moved to the start for
better playback by adding \fIfaststart\fR to the \fImovflags\fR, or
using the \fBqt-faststart\fR tool). A fragmented
file consists of a number of fragments, where packets and metadata
about these packets are stored together. Writing a fragmented
file has the advantage that the file is decodable even if the
writing is interrupted (while a normal \s-1MOV/MP4\s0 is undecodable if
it is not properly finished), and it requires less memory when writing
very long files (since writing normal \s-1MOV/MP4\s0 files stores info about
every single packet in memory until the file is closed). The downside
is that it is less compatible with other applications.
.PP
Fragmentation is enabled by setting one of the AVOptions that define
how to cut the file into fragments:
.IP "\fB\-moov_size\fR \fIbytes\fR" 4
.IX Item "-moov_size bytes"
Reserves space for the moov atom at the beginning of the file instead of placing the
moov atom at the end. If the space reserved is insufficient, muxing will fail.
.IP "\fB\-movflags frag_keyframe\fR" 4
.IX Item "-movflags frag_keyframe"
Start a new fragment at each video keyframe.
.IP "\fB\-frag_duration\fR \fIduration\fR" 4
.IX Item "-frag_duration duration"
Create fragments that are \fIduration\fR microseconds long.
.IP "\fB\-frag_size\fR \fIsize\fR" 4
.IX Item "-frag_size size"
Create fragments that contain up to \fIsize\fR bytes of payload data.
.IP "\fB\-movflags frag_custom\fR" 4
.IX Item "-movflags frag_custom"
Allow the caller to manually choose when to cut fragments, by
calling \f(CW\*(C`av_write_frame(ctx, NULL)\*(C'\fR to write a fragment with
the packets written so far. (This is only useful with other
applications integrating libavformat, not from \fBffmpeg\fR.)
.IP "\fB\-min_frag_duration\fR \fIduration\fR" 4
.IX Item "-min_frag_duration duration"
Don't create fragments that are shorter than \fIduration\fR microseconds long.
.PP
If more than one condition is specified, fragments are cut when
one of the specified conditions is fulfilled. The exception to this is
\&\f(CW\*(C`\-min_frag_duration\*(C'\fR, which has to be fulfilled for any of the other
conditions to apply.
.PP
Additionally, the way the output file is written can be adjusted
through a few other options:
.IP "\fB\-movflags empty_moov\fR" 4
.IX Item "-movflags empty_moov"
Write an initial moov atom directly at the start of the file, without
describing any samples in it. Generally, an mdat/moov pair is written
at the start of the file, as a normal \s-1MOV/MP4\s0 file, containing only
a short portion of the file. With this option set, there is no initial
mdat atom, and the moov atom only describes the tracks but has
a zero duration.
.Sp
Files written with this option set do not work in QuickTime.
This option is implicitly set when writing ismv (Smooth Streaming) files.
.IP "\fB\-movflags separate_moof\fR" 4
.IX Item "-movflags separate_moof"
Write a separate moof (movie fragment) atom for each track. Normally,
packets for all tracks are written in a moof atom (which is slightly
more efficient), but with this option set, the muxer writes one moof/mdat
pair for each track, making it easier to separate tracks.
.Sp
This option is implicitly set when writing ismv (Smooth Streaming) files.
.IP "\fB\-movflags faststart\fR" 4
.IX Item "-movflags faststart"
Run a second pass moving the moov atom on top of the file. This
operation can take a while, and will not work in various situations such
as fragmented output, thus it is not enabled by default.
.IP "\fB\-movflags rtphint\fR" 4
.IX Item "-movflags rtphint"
Add \s-1RTP\s0 hinting tracks to the output file.
.PP
Smooth Streaming content can be pushed in real time to a publishing
point on \s-1IIS\s0 with this muxer. Example:
.PP
.Vb 1
\&        ffmpeg \-re <<normal input/transcoding options>> \-movflags isml+frag_keyframe \-f ismv http://server/publishingpoint.isml/Streams(Encoder1)
.Ve
.SS "mpegts"
.IX Subsection "mpegts"
\&\s-1MPEG\s0 transport stream muxer.
.PP
This muxer implements \s-1ISO\s0 13818\-1 and part of \s-1ETSI\s0 \s-1EN\s0 300 468.
.PP
The muxer options are:
.IP "\fB\-mpegts_original_network_id\fR \fInumber\fR" 4
.IX Item "-mpegts_original_network_id number"
Set the original_network_id (default 0x0001). This is unique identifier
of a network in \s-1DVB\s0. Its main use is in the unique identification of a
service through the path Original_Network_ID, Transport_Stream_ID.
.IP "\fB\-mpegts_transport_stream_id\fR \fInumber\fR" 4
.IX Item "-mpegts_transport_stream_id number"
Set the transport_stream_id (default 0x0001). This identifies a
transponder in \s-1DVB\s0.
.IP "\fB\-mpegts_service_id\fR \fInumber\fR" 4
.IX Item "-mpegts_service_id number"
Set the service_id (default 0x0001) also known as program in \s-1DVB\s0.
.IP "\fB\-mpegts_pmt_start_pid\fR \fInumber\fR" 4
.IX Item "-mpegts_pmt_start_pid number"
Set the first \s-1PID\s0 for \s-1PMT\s0 (default 0x1000, max 0x1f00).
.IP "\fB\-mpegts_start_pid\fR \fInumber\fR" 4
.IX Item "-mpegts_start_pid number"
Set the first \s-1PID\s0 for data packets (default 0x0100, max 0x0f00).
.PP
The recognized metadata settings in mpegts muxer are \f(CW\*(C`service_provider\*(C'\fR
and \f(CW\*(C`service_name\*(C'\fR. If they are not set the default for
\&\f(CW\*(C`service_provider\*(C'\fR is \*(L"FFmpeg\*(R" and the default for
\&\f(CW\*(C`service_name\*(C'\fR is \*(L"Service01\*(R".
.PP
.Vb 9
\&        ffmpeg \-i file.mpg \-c copy \e
\&             \-mpegts_original_network_id 0x1122 \e
\&             \-mpegts_transport_stream_id 0x3344 \e
\&             \-mpegts_service_id 0x5566 \e
\&             \-mpegts_pmt_start_pid 0x1500 \e
\&             \-mpegts_start_pid 0x150 \e
\&             \-metadata service_provider="Some provider" \e
\&             \-metadata service_name="Some Channel" \e
\&             \-y out.ts
.Ve
.SS "null"
.IX Subsection "null"
Null muxer.
.PP
This muxer does not generate any output file, it is mainly useful for
testing or benchmarking purposes.
.PP
For example to benchmark decoding with \fBffmpeg\fR you can use the
command:
.PP
.Vb 1
\&        ffmpeg \-benchmark \-i INPUT \-f null out.null
.Ve
.PP
Note that the above command does not read or write the \fIout.null\fR
file, but specifying the output file is required by the \fBffmpeg\fR
syntax.
.PP
Alternatively you can write the command as:
.PP
.Vb 1
\&        ffmpeg \-benchmark \-i INPUT \-f null \-
.Ve
.SS "matroska"
.IX Subsection "matroska"
Matroska container muxer.
.PP
This muxer implements the matroska and webm container specs.
.PP
The recognized metadata settings in this muxer are:
.IP "\fBtitle=\fR\fItitle name\fR" 4
.IX Item "title=title name"
Name provided to a single track
.IP "\fBlanguage=\fR\fIlanguage name\fR" 4
.IX Item "language=language name"
Specifies the language of the track in the Matroska languages form
.IP "\fBstereo_mode=\fR\fImode\fR" 4
.IX Item "stereo_mode=mode"
Stereo 3D video layout of two views in a single video track
.RS 4
.IP "\fBmono\fR" 4
.IX Item "mono"
video is not stereo
.IP "\fBleft_right\fR" 4
.IX Item "left_right"
Both views are arranged side by side, Left-eye view is on the left
.IP "\fBbottom_top\fR" 4
.IX Item "bottom_top"
Both views are arranged in top-bottom orientation, Left-eye view is at bottom
.IP "\fBtop_bottom\fR" 4
.IX Item "top_bottom"
Both views are arranged in top-bottom orientation, Left-eye view is on top
.IP "\fBcheckerboard_rl\fR" 4
.IX Item "checkerboard_rl"
Each view is arranged in a checkerboard interleaved pattern, Left-eye view being first
.IP "\fBcheckerboard_lr\fR" 4
.IX Item "checkerboard_lr"
Each view is arranged in a checkerboard interleaved pattern, Right-eye view being first
.IP "\fBrow_interleaved_rl\fR" 4
.IX Item "row_interleaved_rl"
Each view is constituted by a row based interleaving, Right-eye view is first row
.IP "\fBrow_interleaved_lr\fR" 4
.IX Item "row_interleaved_lr"
Each view is constituted by a row based interleaving, Left-eye view is first row
.IP "\fBcol_interleaved_rl\fR" 4
.IX Item "col_interleaved_rl"
Both views are arranged in a column based interleaving manner, Right-eye view is first column
.IP "\fBcol_interleaved_lr\fR" 4
.IX Item "col_interleaved_lr"
Both views are arranged in a column based interleaving manner, Left-eye view is first column
.IP "\fBanaglyph_cyan_red\fR" 4
.IX Item "anaglyph_cyan_red"
All frames are in anaglyph format viewable through red-cyan filters
.IP "\fBright_left\fR" 4
.IX Item "right_left"
Both views are arranged side by side, Right-eye view is on the left
.IP "\fBanaglyph_green_magenta\fR" 4
.IX Item "anaglyph_green_magenta"
All frames are in anaglyph format viewable through green-magenta filters
.IP "\fBblock_lr\fR" 4
.IX Item "block_lr"
Both eyes laced in one Block, Left-eye view is first
.IP "\fBblock_rl\fR" 4
.IX Item "block_rl"
Both eyes laced in one Block, Right-eye view is first
.RE
.RS 4
.RE
.PP
For example a 3D WebM clip can be created using the following command line:
.PP
.Vb 1
\&        ffmpeg \-i sample_left_right_clip.mpg \-an \-c:v libvpx \-metadata stereo_mode=left_right \-y stereo_clip.webm
.Ve
.SS "segment, stream_segment, ssegment"
.IX Subsection "segment, stream_segment, ssegment"
Basic stream segmenter.
.PP
The segmenter muxer outputs streams to a number of separate files of nearly
fixed duration. Output filename pattern can be set in a fashion similar to
image2.
.PP
\&\f(CW\*(C`stream_segment\*(C'\fR is a variant of the muxer used to write to
streaming output formats, i.e. which do not require global headers,
and is recommended for outputting e.g. to \s-1MPEG\s0 transport stream segments.
\&\f(CW\*(C`ssegment\*(C'\fR is a shorter alias for \f(CW\*(C`stream_segment\*(C'\fR.
.PP
Every segment starts with a keyframe of the selected reference stream,
which is set through the \fBreference_stream\fR option.
.PP
Note that if you want accurate splitting for a video file, you need to
make the input key frames correspond to the exact splitting times
expected by the segmenter, or the segment muxer will start the new
segment with the key frame found next after the specified start
time.
.PP
The segment muxer works best with a single constant frame rate video.
.PP
Optionally it can generate a list of the created segments, by setting
the option \fIsegment_list\fR. The list type is specified by the
\&\fIsegment_list_type\fR option.
.PP
The segment muxer supports the following options:
.IP "\fBreference_stream\fR \fIspecifier\fR" 4
.IX Item "reference_stream specifier"
Set the reference stream, as specified by the string \fIspecifier\fR.
If \fIspecifier\fR is set to \f(CW\*(C`auto\*(C'\fR, the reference is choosen
automatically. Otherwise it must be a stream specifier (see the ``Stream
specifiers'' chapter in the ffmpeg manual) which specifies the
reference stream. The default value is ``auto''.
.IP "\fBsegment_format\fR \fIformat\fR" 4
.IX Item "segment_format format"
Override the inner container format, by default it is guessed by the filename
extension.
.IP "\fBsegment_list\fR \fIname\fR" 4
.IX Item "segment_list name"
Generate also a listfile named \fIname\fR. If not specified no
listfile is generated.
.IP "\fBsegment_list_flags\fR \fIflags\fR" 4
.IX Item "segment_list_flags flags"
Set flags affecting the segment list generation.
.Sp
It currently supports the following flags:
.RS 4
.IP "\fIcache\fR" 4
.IX Item "cache"
Allow caching (only affects M3U8 list files).
.IP "\fIlive\fR" 4
.IX Item "live"
Allow live-friendly file generation.
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`cache\*(C'\fR.
.RE
.IP "\fBsegment_list_size\fR \fIsize\fR" 4
.IX Item "segment_list_size size"
Update the list file so that it contains at most the last \fIsize\fR
segments. If 0 the list file will contain all the segments. Default
value is 0.
.IP "\fBsegment_list type\fR \fItype\fR" 4
.IX Item "segment_list type type"
Specify the format for the segment list file.
.Sp
The following values are recognized:
.RS 4
.IP "\fBflat\fR" 4
.IX Item "flat"
Generate a flat list for the created segments, one segment per line.
.IP "\fBcsv, ext\fR" 4
.IX Item "csv, ext"
Generate a list for the created segments, one segment per line,
each line matching the format (comma-separated values):
.Sp
.Vb 1
\&        <segment_filename>,<segment_start_time>,<segment_end_time>
.Ve
.Sp
\&\fIsegment_filename\fR is the name of the output file generated by the
muxer according to the provided pattern. \s-1CSV\s0 escaping (according to
\&\s-1RFC4180\s0) is applied if required.
.Sp
\&\fIsegment_start_time\fR and \fIsegment_end_time\fR specify
the segment start and end time expressed in seconds.
.Sp
A list file with the suffix \f(CW".csv"\fR or \f(CW".ext"\fR will
auto-select this format.
.Sp
\&\f(CW\*(C`ext\*(C'\fR is deprecated in favor or \f(CW\*(C`csv\*(C'\fR.
.IP "\fBffconcat\fR" 4
.IX Item "ffconcat"
Generate an ffconcat file for the created segments. The resulting file
can be read using the FFmpeg concat demuxer.
.Sp
A list file with the suffix \f(CW".ffcat"\fR or \f(CW".ffconcat"\fR will
auto-select this format.
.IP "\fBm3u8\fR" 4
.IX Item "m3u8"
Generate an extended M3U8 file, version 3, compliant with
<\fBhttp://tools.ietf.org/id/draft\-pantos\-http\-live\-streaming\fR>.
.Sp
A list file with the suffix \f(CW".m3u8"\fR will auto-select this format.
.RE
.RS 4
.Sp
If not specified the type is guessed from the list file name suffix.
.RE
.IP "\fBsegment_time\fR \fItime\fR" 4
.IX Item "segment_time time"
Set segment duration to \fItime\fR, the value must be a duration
specification. Default value is \*(L"2\*(R". See also the
\&\fBsegment_times\fR option.
.Sp
Note that splitting may not be accurate, unless you force the
reference stream key-frames at the given time. See the introductory
notice and the examples below.
.IP "\fBsegment_time_delta\fR \fIdelta\fR" 4
.IX Item "segment_time_delta delta"
Specify the accuracy time when selecting the start time for a
segment, expressed as a duration specification. Default value is \*(L"0\*(R".
.Sp
When delta is specified a key-frame will start a new segment if its
\&\s-1PTS\s0 satisfies the relation:
.Sp
.Vb 1
\&        PTS >= start_time \- time_delta
.Ve
.Sp
This option is useful when splitting video content, which is always
split at \s-1GOP\s0 boundaries, in case a key frame is found just before the
specified split time.
.Sp
In particular may be used in combination with the \fIffmpeg\fR option
\&\fIforce_key_frames\fR. The key frame times specified by
\&\fIforce_key_frames\fR may not be set accurately because of rounding
issues, with the consequence that a key frame time may result set just
before the specified time. For constant frame rate videos a value of
1/2*\fIframe_rate\fR should address the worst case mismatch between
the specified time and the time set by \fIforce_key_frames\fR.
.IP "\fBsegment_times\fR \fItimes\fR" 4
.IX Item "segment_times times"
Specify a list of split points. \fItimes\fR contains a list of comma
separated duration specifications, in increasing order. See also
the \fBsegment_time\fR option.
.IP "\fBsegment_frames\fR \fIframes\fR" 4
.IX Item "segment_frames frames"
Specify a list of split video frame numbers. \fIframes\fR contains a
list of comma separated integer numbers, in increasing order.
.Sp
This option specifies to start a new segment whenever a reference
stream key frame is found and the sequential number (starting from 0)
of the frame is greater or equal to the next value in the list.
.IP "\fBsegment_wrap\fR \fIlimit\fR" 4
.IX Item "segment_wrap limit"
Wrap around segment index once it reaches \fIlimit\fR.
.IP "\fBsegment_start_number\fR \fInumber\fR" 4
.IX Item "segment_start_number number"
Set the sequence number of the first segment. Defaults to \f(CW0\fR.
.IP "\fBreset_timestamps\fR \fI1|0\fR" 4
.IX Item "reset_timestamps 1|0"
Reset timestamps at the begin of each segment, so that each segment
will start with near-zero timestamps. It is meant to ease the playback
of the generated segments. May not work with some combinations of
muxers/codecs. It is set to \f(CW0\fR by default.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
To remux the content of file \fIin.mkv\fR to a list of segments
\&\fIout\-000.nut\fR, \fIout\-001.nut\fR, etc., and write the list of
generated segments to \fIout.list\fR:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list out.list out%03d.nut
.Ve
.IP "\(bu" 4
As the example above, but segment the input file according to the split
points specified by the \fIsegment_times\fR option:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list out.csv \-segment_times 1,2,3,5,8,13,21 out%03d.nut
.Ve
.IP "\(bu" 4
As the example above, but use the \f(CW\*(C`ffmpeg\*(C'\fR \fIforce_key_frames\fR
option to force key frames in the input at the specified location, together
with the segment option \fIsegment_time_delta\fR to account for
possible roundings operated when setting key frame times.
.Sp
.Vb 2
\&        ffmpeg \-i in.mkv \-force_key_frames 1,2,3,5,8,13,21 \-codec:v mpeg4 \-codec:a pcm_s16le \-map 0 \e
\&        \-f segment \-segment_list out.csv \-segment_times 1,2,3,5,8,13,21 \-segment_time_delta 0.05 out%03d.nut
.Ve
.Sp
In order to force key frames on the input file, transcoding is
required.
.IP "\(bu" 4
Segment the input file by splitting the input file according to the
frame numbers sequence specified with the \fIsegment_frames\fR option:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list out.csv \-segment_frames 100,200,300,500,800 out%03d.nut
.Ve
.IP "\(bu" 4
To convert the \fIin.mkv\fR to \s-1TS\s0 segments using the \f(CW\*(C`libx264\*(C'\fR
and \f(CW\*(C`libfaac\*(C'\fR encoders:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-map 0 \-codec:v libx264 \-codec:a libfaac \-f ssegment \-segment_list out.list out%03d.ts
.Ve
.IP "\(bu" 4
Segment the input file, and create an M3U8 live playlist (can be used
as live \s-1HLS\s0 source):
.Sp
.Vb 2
\&        ffmpeg \-re \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list playlist.m3u8 \e
\&        \-segment_list_flags +live \-segment_time 10 out%03d.mkv
.Ve
.SS "mp3"
.IX Subsection "mp3"
The \s-1MP3\s0 muxer writes a raw \s-1MP3\s0 stream with an ID3v2 header at the beginning and
optionally an ID3v1 tag at the end. ID3v2.3 and ID3v2.4 are supported, the
\&\f(CW\*(C`id3v2_version\*(C'\fR option controls which one is used. The legacy ID3v1 tag is
not written by default, but may be enabled with the \f(CW\*(C`write_id3v1\*(C'\fR option.
.PP
For seekable output the muxer also writes a Xing frame at the beginning, which
contains the number of frames in the file. It is useful for computing duration
of \s-1VBR\s0 files.
.PP
The muxer supports writing ID3v2 attached pictures (\s-1APIC\s0 frames). The pictures
are supplied to the muxer in form of a video stream with a single packet. There
can be any number of those streams, each will correspond to a single \s-1APIC\s0 frame.
The stream metadata tags \fItitle\fR and \fIcomment\fR map to \s-1APIC\s0
\&\fIdescription\fR and \fIpicture type\fR respectively. See
<\fBhttp://id3.org/id3v2.4.0\-frames\fR> for allowed picture types.
.PP
Note that the \s-1APIC\s0 frames must be written at the beginning, so the muxer will
buffer the audio frames until it gets all the pictures. It is therefore advised
to provide the pictures as soon as possible to avoid excessive buffering.
.PP
Examples:
.PP
Write an mp3 with an ID3v2.3 header and an ID3v1 footer:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-id3v2_version 3 \-write_id3v1 1 out.mp3
.Ve
.PP
To attach a picture to an mp3 file select both the audio and the picture stream
with \f(CW\*(C`map\*(C'\fR:
.PP
.Vb 2
\&        ffmpeg \-i input.mp3 \-i cover.png \-c copy \-map 0 \-map 1
\&        \-metadata:s:v title="Album cover" \-metadata:s:v comment="Cover (Front)" out.mp3
.Ve
.SS "ogg"
.IX Subsection "ogg"
Ogg container muxer.
.IP "\fB\-page_duration\fR \fIduration\fR" 4
.IX Item "-page_duration duration"
Preferred page duration, in microseconds. The muxer will attempt to create
pages that are approximately \fIduration\fR microseconds long. This allows the
user to compromise between seek granularity and container overhead. The default
is 1 second. A value of 0 will fill all segments, making pages as large as
possible. A value of 1 will effectively use 1 packet-per-page in most
situations, giving a small seek granularity at the cost of additional container
overhead.
.SS "tee"
.IX Subsection "tee"
The tee muxer can be used to write the same data to several files or any
other kind of muxer. It can be used, for example, to both stream a video to
the network and save it to disk at the same time.
.PP
It is different from specifying several outputs to the \fBffmpeg\fR
command-line tool because the audio and video data will be encoded only once
with the tee muxer; encoding can be a very expensive process. It is not
useful when using the libavformat \s-1API\s0 directly because it is then possible
to feed the same packets to several muxers directly.
.PP
The slave outputs are specified in the file name given to the muxer,
separated by '|'. If any of the slave name contains the '|' separator,
leading or trailing spaces or any special character, it must be
escaped (see the ``Quoting and escaping'' section in the ffmpeg-utils
manual).
.PP
Options can be specified for each slave by prepending them as a list of
\&\fIkey\fR=\fIvalue\fR pairs separated by ':', between square brackets. If
the options values contain a special character or the ':' separator, they
must be escaped; note that this is a second level escaping.
.PP
Example: encode something and both archive it in a WebM file and stream it
as MPEG-TS over \s-1UDP\s0 (the streams need to be explicitly mapped):
.PP
.Vb 2
\&        ffmpeg \-i ... \-c:v libx264 \-c:a mp2 \-f tee \-map 0:v \-map 0:a
\&          "archive\-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/"
.Ve
.PP
Note: some codecs may need different options depending on the output format;
the auto-detection of this can not work with the tee muxer. The main example
is the \fBglobal_header\fR flag.
.SH "METADATA"
.IX Header "METADATA"
FFmpeg is able to dump metadata from media files into a simple UTF\-8\-encoded
INI-like text file and then load it back using the metadata muxer/demuxer.
.PP
The file format is as follows:
.IP "1." 4
A file consists of a header and a number of metadata tags divided into sections,
each on its own line.
.IP "2." 4
The header is a ';FFMETADATA' string, followed by a version number (now 1).
.IP "3." 4
Metadata tags are of the form 'key=value'
.IP "4." 4
Immediately after header follows global metadata
.IP "5." 4
After global metadata there may be sections with per\-stream/per\-chapter
metadata.
.IP "6." 4
A section starts with the section name in uppercase (i.e. \s-1STREAM\s0 or \s-1CHAPTER\s0) in
brackets ('[', ']') and ends with next section or end of file.
.IP "7." 4
At the beginning of a chapter section there may be an optional timebase to be
used for start/end values. It must be in form 'TIMEBASE=num/den', where num and
den are integers. If the timebase is missing then start/end times are assumed to
be in milliseconds.
Next a chapter section must contain chapter start and end times in form
\&'START=num', 'END=num', where num is a positive integer.
.IP "8." 4
Empty lines and lines starting with ';' or '#' are ignored.
.IP "9." 4
Metadata keys or values containing special characters ('=', ';', '#', '\e' and a
newline) must be escaped with a backslash '\e'.
.IP "10." 4
Note that whitespace in metadata (e.g. foo = bar) is considered to be a part of
the tag (in the example above key is 'foo ', value is ' bar').
.PP
A ffmetadata file might look like this:
.PP
.Vb 4
\&        ;FFMETADATA1
\&        title=bike\e\eshed
\&        ;this is a comment
\&        artist=FFmpeg troll team
\&        
\&        [CHAPTER]
\&        TIMEBASE=1/1000
\&        START=0
\&        #chapter ends at 0:01:00
\&        END=60000
\&        title=chapter \e#1
\&        [STREAM]
\&        title=multi\e
\&        line
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIffmpeg\fR\|(1), \fIffplay\fR\|(1), \fIffprobe\fR\|(1), \fIffserver\fR\|(1), \fIlibavformat\fR\|(3)
.SH "AUTHORS"
.IX Header "AUTHORS"
The FFmpeg developers.
.PP
For details about the authorship, see the Git history of the project
(git://source.ffmpeg.org/ffmpeg), e.g. by typing the command
\&\fBgit log\fR in the FFmpeg source directory, or browsing the
online repository at <\fBhttp://source.ffmpeg.org\fR>.
.PP
Maintainers for the specific components are listed in the file
\&\fI\s-1MAINTAINERS\s0\fR in the source code tree.
